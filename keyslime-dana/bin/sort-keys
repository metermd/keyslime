#!/usr/bin/env bash

# This program looks at a directory of keys and decides which is "active", based
# on the current time, which are "future" (upcoming), and which are "old".
#
# It then creates links which are stable, and may be used in a static config
# file (nginx, apache, etc).
#
# The idea is that software needs ONE "active" key, which it encrypts new
# sessions with, but has a lot of older keys which are expiring.  It still
# accepts these, but does not initiate with them.
#
# However, due to the inherit unreliability of the network, the software STILL
# probably wants to accept connections with future keys.  This is in case its
# peers have moved forward, and, for whatever reason, this node hasn't.  This
# simplifies the problem to just isolating the keys into two buckets: active and
# accept-only.
#
# What if we've run out of future keys?  Fuck.  The optimal strategy is to keep
# initiating sessions with the most recent key we have, because our peers will
# keep accepting that key on their "old" list the longest, and hope the network
# comes back up, or someone steps in before we're generating sessions with keys
# our peers won't recognize.
#
# We try to optimize the ordering of the list so that more-likely "hits" out
# of the inactive list are hit first.  In normal operation, this will look like
# this:
#
# Existing Keys:
#   future1, future2, future3, active, old1, old2, old3, old4, old5, oldn...
# Solution:
#   active, old1, future3, old2, future2, old3, old4, old5, oldn..., future1
#
# This is so software that processes the list in order will hit something useful
# near the head of the list.
#
# So far, this has been the most annoying component to write in Bash, but please
# try to follow along with our array technology.

BINS=$(dirname "$0")
source "$BINS/portability.bash"

declare -a OLD
declare -a FUTURE
declare -a RESULTS
ACTIVE=''

NOW=$(date -u '+%s')

# This is the file we expect to exist and be the dividing line.
CURRENT=$(adjdate "$NOW" 0).ticket-key

# Sort them into arrays OLD, FUTURE, and a scalar: ACTIVE
for i in $(ls -1 *.ticket-key | sort -r); do
  if [[ "$i" < "$CURRENT" ]]; then
    OLD+=("$i")
  elif [[ "$i" > "$CURRENT" ]]; then
    FUTURE+=("$i")
  else
    ACTIVE="$i"
  fi
done

# If we have a key that matches the current hour, it goes at the head of the
# list.
if [ ! -z "$ACTIVE" ]; then
  RESULTS+=("$ACTIVE")
fi

# While either OLD or FUTURE have elements, interleave a value from
# OLD and then from FUTURE into RESULTS
while [[ $((${#FUTURE[@]} + ${#OLD[@]})) -gt 0 ]] ; do
  # result.push(old.pop) unless old.empty?
  if [[ ${#OLD[@]} -gt 0 ]]; then
    RESULTS+=("${OLD[0]}")
    OLD=("${OLD[@]:1}")
  fi

  # result.push(future.shift) unless future.empty?
  if [[ ${#FUTURE[@]} -gt 0 ]]; then
    RESULTS+=("${FUTURE[${#FUTURE[@]}-1]}")
    FUTURE=("${FUTURE[@]:0:${#FUTURE[@]}-1}")
  fi
done

mkdir -p 'sorted'
ln -s "${RESULTS[0]}" 'sorted/active.key'

# Each that remains, accounting for the active.key we've already linked.
for i in $(seq 1 $((${#RESULTS[@]} - 1)) ); do
  FILENAME=$(printf 'sorted/inactive-%02d.key' "$i")
  ln -s "${RESULTS[i]}" "$FILENAME"
done
